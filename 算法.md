

# KMP算法

```java
//暴力算法
class Solution {
    public int strStr(String haystack, String needle) {
        int n1=haystack.length();
        int n2=needle.length();
        if(n2==0) return 0;
        for(int i=0;i<=n1-n2;i++){
            if(haystack.charAt(i)==needle.charAt(0)){
                int j=0;
                for(;j<n2;j++){
                    if(haystack.charAt(i+j)!=needle.charAt(j)){
                        break;
                    }
                }
                if(j==n2){
                    return i;
                }
            }
        }
        return -1;
    }
}
```

KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n) [1] 。

与暴力算法不同的是，匹配失败后

<font color="red">**主串的指针不回退，字串的指针回退到某个位置**</font>

<font color="green">**1、字符串的前缀、后缀和部分匹配值**</font>

前缀：除了最后一个字符外，所有的头部字符串

后缀：除了第一个字符外，所有的尾部字符串

部分匹配值：前缀和后缀的最长相等前后长度

对于`ababa`

'a'的前缀和后缀都为空集，最长相等前后缀长度为0。

'ab'的前缀为{a}，后缀为{b}，最长相等前后缀长度为0。

'ab'的前缀为{a,ab}，后缀为{a, b a }, { a, ab}门{a,ba}={a}，最长相等前后缀长度为1。

'abab'的前缀{a,ab,aba}n后缀{b,ab,bab}={ab}，最长相等前后缀长度为2。

'ababa'的前缀{a,ab,aba,abab},后缀{a,ba,aba,baba}={a,aba}，公共元素有两个，最长相等前后缀长度为3。

匹配值分别为00123

| 下标 | 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 数值 | 0    | 0    | 1    | 2    | 3    |

将数值右移

| 下标 | 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 数值 | -1   | 0    | 0    | 1    | 2    |

引出next数组

<font color="green">**2、next数组的求解**</font>

对于next求解，我们一般假设next[i]=k,然后递推得到next[i+1]

![Snipaste_2022-01-02_19-03-11](D:\汪福明\Desktop\Snipaste_2022-01-02_19-03-11.png)

当i=4是，next[4]的数值是1

这就默认了<font color="purple">**p<sub>0</sub>...p<sub>k-1</sub>=p<sub>i-k</sub>...p<sub>i-1</sub>**</font>

> 可以在后面的i=7，8，9，10进行验证

当p<sub>k</sub>==p<sub>i</sub>时，next[i+1]=k+1;

当p<sub>k</sub>!=p<sub>i</sub>需要回退，我们以i==5求next[6]为例

next[5]==2

p<sub>2</sub>=c, p<sub>5</sub>=a,继续回退，next[2]=0,p<sub>0</sub>=a，这是两者相等

next[6]=k+1=0+1=1;

# 动态规划

动态规划是分治思想的延续，通俗来说就是大事化小，小事化了

在将大问题化为小问题时，保存对这些小问题已经处理好的结果，以供后面使用

1、定义状态

2、转移方程

3、终止条件

# 背包问题

## 01背包问题

题目：有N 件物品和一个容量为V 的背包。放入第i件物品耗费的费用是A[i]，得到的价值是W[i]。求解将哪些物品装入背包可使价值总和最大。

这是基本背包问题，其特点是:<font color="red">**每种物品仅有一件，可以选择放或不放。**</font>

<font color="Magenta">**定义状态**</font>：`dp[i][j]`表示背包容量为j时前i物品所所得最大值

<font color="Magenta">**转移方程**</font>：`dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-A[i]]+W[i])`

<font color="Magenta">**初始条件**</font>：

1、如果需要**包满**的最大值，`dp[0][0]=0,dp[0][other]=Integer.MIN_VALUE;`

很简单，当没有放东西时，包的价值为0，如果空间大于0，那么就会有**空余空间没有使用**

2、如果只需要最大值`dp[0][all]=0,dp[all][0]=0`

<font color="Magenta">**终止条件**</font>：

```java
for i <- 1 to N
    for j <- 1 to V
```



时间复杂度：O(mn)，空间复杂度：O(mn)

<font color="Magenta">**优化问题**</font>：

二维通常可以优化为以为，我们发现数据都是对**上一行进行变化**

我们就可以直接用一个一维数组来存储数组

需要注意的是，二维转换一维数组后遍历顺序需要改变

`dp[j]=Math.max(dp[j],dp[j-A[i]]+w[i])`

## 完全背包问题

题目：有N 件物品和一个容量为V 的背包。放入第i 件物品耗费的费用是A[i]，得到的价值是W[i]。求解将哪些物品装入背包可使价值总和最大。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。

这个问题非常类似于01 背包问题，所不同的是每种物品有无限件。

# 快速乘、快速幂

```c
int quickMulti(int A, int B) {
    int ans = 0;
    for ( ; B; B >>= 1) {
        if (B & 1) {
            ans += A;
        }
        A <<= 1;
    }
    return ans;
}
```

```java
public double quickMul(double x, long N) {
    if (N == 0) {
        return 1.0;
    }
    double y = quickMul(x, N / 2);
    return N % 2 == 0 ? y * y : y * y * x;
}
//妙到家了
public double quickMul(double x, long N) {
    double ans = 1.0;
        // 贡献的初始值为 x
    double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
    while (N > 0) {
        if (N % 2 == 1) {
            // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
            ans *= x_contribute;
        }
        // 将贡献不断地平方
        x_contribute *= x_contribute;
        // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
       N /= 2;
    }
    return ans;
}
```



