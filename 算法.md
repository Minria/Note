

# KMP算法



```java
//暴力算法
class Solution {
    public int strStr(String haystack, String needle) {
        int n1=haystack.length();
        int n2=needle.length();
        if(n2==0) return 0;
        for(int i=0;i<=n1-n2;i++){
            if(haystack.charAt(i)==needle.charAt(0)){
                int j=0;
                for(;j<n2;j++){
                    if(haystack.charAt(i+j)!=needle.charAt(j)){
                        break;
                    }
                }
                if(j==n2){
                    return i;
                }
            }
        }
        return -1;
    }
}
```

KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n) [1] 。

与暴力算法不同的是，匹配失败后

<font color="red">**主串的指针不回退，字串的指针回退到某个位置**</font>

<font color="green">**1、字符串的前缀、后缀和部分匹配值**</font>

前缀：除了最后一个字符外，所有的头部字符串

后缀：除了第一个字符外，所有的尾部字符串

部分匹配值：前缀和后缀的最长相等前后长度

对于`ababa`

'a'的前缀和后缀都为空集，最长相等前后缀长度为0。

'ab'的前缀为{a}，后缀为{b}，最长相等前后缀长度为0。

'ab'的前缀为{a,ab}，后缀为{a, b a }, { a, ab}门{a,ba}={a}，最长相等前后缀长度为1。

'abab'的前缀{a,ab,aba}n后缀{b,ab,bab}={ab}，最长相等前后缀长度为2。

'ababa'的前缀{a,ab,aba,abab},后缀{a,ba,aba,baba}={a,aba}，公共元素有两个，最长相等前后缀长度为3。

匹配值分别为00123

| 下标 | 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 数值 | 0    | 0    | 1    | 2    | 3    |

将数值右移

| 下标 | 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 数值 | -1   | 0    | 0    | 1    | 2    |

引出next数组

<font color="green">**2、next数组的求解**</font>

对于next求解，我们一般假设next[i]=k,然后递推得到next[i+1]

![Snipaste_2022-01-02_19-03-11](D:\汪福明\Desktop\Snipaste_2022-01-02_19-03-11.png)

当i=4是，next[4]的数值是1

这就默认了<font color="purple">**p<sub>0</sub>...p<sub>k-1</sub>=p<sub>i-k</sub>...p<sub>i-1</sub>**</font>

> 可以在后面的i=7，8，9，10进行验证

当p<sub>k</sub>==p<sub>i</sub>时，next[i+1]=k+1;

当p<sub>k</sub>!=p<sub>i</sub>需要回退，我们以i==5求next[6]为例

next[5]==2

p<sub>2</sub>=c, p<sub>5</sub>=a,继续回退，next[2]=0,p<sub>0</sub>=a，这是两者相等

next[6]=k+1=0+1=1;

# 动态规划

动态规划是分治思想的延续，通俗来说就是大事化小，小事化了

在将大问题化为小问题时，保存对这些小问题已经处理好的结果，以供后面使用

1、定义状态

2、转移方程

3、终止条件
