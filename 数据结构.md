[TOC]

# 线性表

## 线性表的定义及基本表示

### 线性表的定义

线性表是具有**相同**数据类型的n个数据元素的有限集合。

### 基本操作

```c
void InitList(&L);//初始化表。构造一个空的线性表。
int Length(L);//求表长。返回线性表L的长度，即L中数据元素的个数。
void LocateElem(L,e);//按值查找操作。在表L中查找具有给定关键字值的元素。
void GetElem(L,i);//按位查找操作。获取表L中第i个位置的元素的值。
void ListInsert(&L,i,e);//插入操作。在表L中的第i个位置上插入指定元素e。
void ListDelete(&L,i,&e);//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值
void PrintList(L);//输出操作。按前后顺序输出线性表L的所有元素值。
bool Empty(L);//判空操作。若L为空表，则返回true,否则返回false。
void DestroyList(&L);//销毁操作。销毁线性表，并释放线性表L所占用的内存空间。
```

## 顺序表

### 顺序表的定义

**简而言之，数组**。这就是说，顺序表的底层是通过数组来实现的。

静态数组版

```c
#define MaxSize 50//定义线性表最大长度
typedef struct{
    int data[MaxSize];//顺序表的元素，以int型数据为例
    int length;//顺序表当前长度
}SqList;
```

动态数组版

```c
#define InitSize 100//表长度初始定义
typedef struct{
    int* data;//指示动态分配数组的指针
    int MaxSize,length;//数组最大容量和当前容量
}SeqList;
L.data=(int*)malloc(sizeof(int)*InitSize);
```

### 顺序表的基本操作

#### 增删查改

## 线性表的链式表示

### 单链表的定义

```c
//C语言版
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode;
```

### 链表的建立

```c
//C语言版
//头插法
LNode* headInsert(LNode* head) {
	LNode* p1;
	p1 = (LNode*)malloc(sizeof(LNode));
	printf("输入数据>");
	scanf("%d", &(p1->data));
	p1->next = head;
	head = p1;
	return head;
}
//先前链表1->2->3->4->NULL
//插入后5->1->2->3->4->NULL
//尾插法
LNode* tailInsert(LNode* head) {
	LNode* p1 = head, * p2;//p1用来帮助我们找到尾结点，p2用来插入
	while (p1->next) {
		p1 = p1->next;
	}
	p2 = (LNode*)malloc(sizeof(LNode));
	printf("输入数据>");
	scanf("%d", &(p2->data));
	p1->next = p2;
	p2->next = NULL;//尾结点后面没有了需要加NULL
	return head;
}
//1->2->3->4->NULL
//1->2->3->4->5???
//1->2->3->4->5->NULL
```

### 链表的操作

#### 插入节点

```c
void ListInsert(&L,i,e);
```

要想在第i个位置插入元素e，就要找到i-1的位置，假设第i-1个结点是\*p，然后将新结点\*q插入其后。

```c
q->next=p->next;
p->next=s;
```

在很多境况我们采用的是尾插法，那要是插在头节点前呢？

#### 删除结点

删除结点需要找到前驱结点

假设\*p为前驱结点

```c
q=p->next;
p->next=q->next;
free(q);
```

也可以将后面结点覆盖前面结点

假设\*p为被删除结点

```c
q=p->next;
p->data=q->data;
p->next=q->next;
free(q);
```

需要注意的，第一个结点不能删除头结点，第二个方法不能删除尾结点。

对于常规插入删除好像都不能顾全面，这时候可以在头节点前面加一个哑结点，那样就不能考虑对头节点插入删除的困扰。

## 双链表

# 栈

## 栈的基本概念

### 栈的定义

1. 栈（Stack）是只允许在一段进行插入或者删除的线性表。
2. 栈顶（Top）。线性表允许进行删除的那一端。
3. 栈底（Bottom）。固定，不允许插入删除。
4. 空栈。不含任何元素。

### 栈的基本操作

```c
void InitStack(&S);//初始化一个空栈s。
bool StackEmpty(S);//判断一个栈是否为空， 若栈s 为空则返回true,否则返回false。
void Push(&S,x);//进栈，若栈s未满， 则将x加入使之成为新栈顶。
void Pop(&S,&x);//出栈，若栈s非空，则弹出栈顶元素， 并用x返回。
void GetTop(S,&x);//读栈顶元素，若栈s非空， 则用x返回栈顶元素。
void DestroyStack(&S);//销毁栈， 并释放栈s占用的存储空间。
```

### 栈的存储结构

#### 顺序栈

```c
#define MaxSize 50//栈中元素最大个数
typedef struct{
    int data[MaxSize];//存放栈中元素
    int top;//栈顶指针
}SqStack;
```

栈顶指针：S.top,初始时设置s.top=-1;栈顶元素：S.data[S.top]。

进栈操作：栈不满时， 栈顶指针先加1,再送值到栈顶元素。

出栈操作：栈非空时， 先取栈顶元素值， 再将栈顶指针减1 。

栈空条件：S.top= =-1; 

栈满条件：S.top= =MaxSize-1;

栈长：S.top+1。

#### 链式栈

```c
typedef struct Linknode{
    int data;
    struct Linknode *next;
}*LiStack;
```

> 插入删除在表头执行

# 队列

## 队列的基本概念

### 队列的定义

队列（Queue），也是一种操作受限的线性表，只允许在一段进行插入并且在另一端进行删除。

### 队列的操作

```c
void InitQueue(&Q);//初始化队列，构造一个空队列Q。
bool QueueErnpty(Q);//判队列空，若队列Q为空返回七rue,否则返回false。
void EnQueue(&Q,x);//入队，若队列Q未满，将x加入，使之成为新的队尾。
void DeQueue(&Q,x);//出队，若队列Q非空，删除队头元素，并用x返回。
void GetHead(Q, &x);//读队头元素，若队列Q非空，则将队头元素赋值给x。
```

### 队列的存储结构

#### 顺序队

```c
#define MaxSize 50//定义队列中元素的最大个数
typedef struct{
int data[MaxSize];//存放队列元素
int front,rear;//队头指针和队尾指针
}SqQueue;
```

初始状态（队空条件）：Q.front = =Q.rear= = 0。

进队操作：队不满时， 先送值到队尾元素， 再将队尾指针加1。

出队操作：队不空时， 先取队头元素值， 再将队头指针加1。

#### 循坏队

#### 链式队

```c
typedef struct{
    int data;
struct LinkNode *next;
}LinkNode;
typedef struct{ 
    LinkNode *front,*rear; ／／队列的队头和队尾指针
}LinkQueue; 
```

```c
void InitQueue(LinkQueue &Q){
    Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));
    Q.front->next=NULL;
}
bool IsEmpty(LinkQueue Q){
    if(Q.front==Q.rear)
        return true;
    else
        return false;
}
void EnQueue(LinkQueue &Q,int x){
    LinkNode* s=(LinkNode*)malloc(sizeof(LinkNode));
    s->data=x;
    s->next=NULL;
    Q.rear->next=s;
    Q.rear=s;
}
bool DeQueue(LinkQueue &Q,int* x){
    if(Q.front==Q.rear)
        return false;
    LinkNode*p=Q.front->next;
    x=p->data;
    Q.front->next=p->next;
    if(Q.rear==p)
        Q.rear=Q.front;
    free(p);
    return true;
}
```

## 双端队列

# 树和二叉树

## 树的基本概念

### 树的定义

树是n个结点的有限集。当n=0时，称为空树。

1. 有且仅有一个根结点
2. 当n>1时，其余结点可以分为m个互不相交的有限集，每个集合又是一棵树。

树的特点

1. 树的根结点没有前驱，除了根结点外的所有结点都有且只有一个前驱
2. 树中所有结点可以有零个或者多个后继。

### 基本术语

![Snipaste_2021-10-11_19-10-59](https://gitee.com/wang-fuming/dawning/raw/master/202110111911531.png)



考虑结点K。 根A到结点K的唯 路径上的任意结点，称为结点K的祖先。 如结点B 是
结点K的祖先， 而结点K是结点B的子孙。 路径上最接近结点K的结点E称为K的双
亲， 而K为结点E的孩子。 根A是树中唯有双亲的结点。 有相同双亲的结点称为兄弟， 如结点K和结点L有相同的双亲E, 即K和L为兄弟。

树中 个结点的孩子个数称为该结点的度， 树中结点的最大度数称为树的度。 如结点 B
的度为2, 结点D的度为3 ,树的度为3。

度大千0的结点称为分支结点 （又称非终端结点）；度为0（没有子女结点） 的结点称为
叶子结点（又称终端结点）。 在分支结点中， 每个结点的分支数就是该结点的度。

结点的深度、 高度和层次。

结点的层次从树根开始定义， 根结点为第1层， 它的子结点为第2层， 以此类推。 双亲在同一层的结点互为堂兄弟， 图5.1中结点G与E,F, H, I, J互为堂兄弟。结点的深度是从根结点开始自顶向下逐层累加的。结点的高度是从叶结点开始自底向上逐层累加的。
树的高度 （或深度） 是树中结点的最大层数。 图5.1中树的高度为4。

有序树和无序树。 树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。 假设图5.1为有序树，若将子结点位置互换， 则变成 棵不同的树。

路径和路径长度。 树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的， 而路径长度是路径上所经过的边的个数。
**注意**： 由于树中的分支是有向的， 即从双亲指向孩子， 所以树中的路径是从上向下的， 同一双亲的两个孩子之间不存在路径。

### 树的性质

> 1. 树中结点数等于所有结点的度数之和加1.
> 2. 度为m的数中第i层至多有m<sup>i-1</sup>个结点
> 3. 高度为h的m叉数至多有（m<sup>h</sup>-1）/(m-1)个结点
> 4. 具有n个结点的m叉数最小高度时log<sub>m</sub>(n(m-1)+1)



## 二叉树

### 二叉树的定义及主要特性

#### 二叉树的定义

二叉树也是一种树形结构，其特点是每个结点至多只有两个子树，并且二叉树的子树有左右之分，其次序不能任意颠倒。

#### 特殊的二叉树

![Snipaste_2021-10-11_19-13-10](https://gitee.com/wang-fuming/dawning/raw/master/202110111913714.png)

1. 满二叉树

   一颗树的高度为h，且含有

2. 完全二叉树

### 二叉树的存储结构

```c
typedef struct BitNode{
    int data;
    struct BitNode *lchild,*rchild;
}BiTNode;
```

### 二叉树的遍历

1. 先序遍历

   操作如下

   如果是空树，什么也不做，否则

   1. 访问跟结点
   2. 遍历左子树
   3. 遍历右子树

   ```c
   //伪代码
   //递归形式
   void Preorder(BiTree T){
       if(T){
           visit(T);
           Inorder(T->lchild);
           Inorder(T->rchild);
       }
   }
   //非递归，借助栈来完成
   void PreOrder(Bitree T){
       InitStack(S);//初始化一个栈
       BiTree p=T;
       while(p||!Empty(S)){
           if(p){
               visit(p);
               Push(S,p);
               p=p->lchild;
           }
           else{
               Pop(S,p);
               p=p->rchild;
           }
       }
   }
   ```
   
   2. 后序遍历
   
        操作如下
   
      如果是空树，什么也不做，否则
   
      1. 遍历左子树
      2. 访问根结点
      3. 遍历右子树
   
   
   
   ```c
   void Inorder(BiTree T){
       if(T){
           Inorder(T->lchild);
           Visit(T);
           Inorder(T->rchild);
       }
   }
   ```
   
   
   
   3. 后序遍历
   
        操作如下
   
      如果是空树，什么也不做，否则
   
      1. 遍历左子树
      2. 遍历右子树
      3. 访问根结点   
   
   ```c
   void PostOrder(BiTree T){
       if(T){
           PostOrder(T->lchild);
           PostOrder(T->rchild);
           visit(T);
       }
   }
   ```
   
   4. 层次遍历
   
   ```c
   void LeverOrder(BiTree T){
       InitQueue(Q);
       BiTree p;
       EnQueue(Q,T);
       while(!IsEmpty(Q)){
           DeQueue(Q,p);
           visit(p);
           if(p->lchild)
               EnQueue(Q,p->lchild);
           if(p->rchild)
               EnQueue(Q,p->rchild);
       }
   }
   ```
   
   
   
   ### 线索二叉树
   
   #### 线索二叉树的基本概念
   
   ```c
   typedef struct ThreadNode{
       int data;
       struct ThreadNode *lchild,*rchild;
       int ltag,rtag;
   }ThreadNode,*ThreadTree;
   ```
   
   ## 树和森林
   
   ### 树的存储结构
   
   1. 双亲表示法
   
   ```c
   #define MAX_TREE_SIZE 100
   typedef struct{
       int data;
       int parent;
   }PTNode;
   typedef struct{
       PTNode nodes[MAX_TREE_SIZE];
       int n;
   }PTree;
   ```
   
   2. 孩子表示法
   3. 孩子兄弟表示法
   
   ```c
   typedef struct CSNode{
       int data;
       struct CSNode *firstchild,*nexts;
   }CSNode,*CSTree;
   ```
   
   # 图
   
   ## 图的储存和基本操作
   
   1. 邻接矩阵法
   
   ```c
   #define MaxVertexNum 100
   typedef char VertexType;
   typedef int EdgeType;
   typedef struct{
       VertexType Vex[MaxVertexNum];//顶点表
       EdgeType Edge[MaxVertexNum][MaxVertexNum];//领接矩阵
       int vexnum,arcnum;//当前顶点数和弧数
   }
   ```



# 查找

## 顺序查找

1. 对于顺序表，可通过数组下标扫描

2. 对于链表，可通过next指针进行扫描

### 一般表的顺序查找

基本思想:从线性表一端开始，逐个检查关键字是否满足条件

```c
typedef struct{
    int* elem;
    int TableLen;
}SSTable;
int Search_Seq(SSTable ST,int key){
    ST.elem[0]=key;
    for(i=ST.TableLen;ST.elem[i]!=key;--i)
        return i;
}
```

### 有序表的顺序查找

## 折半查找

又称二分查找，**仅适用有序表**

```c
int BinarySearch(SeqList L,int key){
    int low=0,hight=L.TableLen-1,mid;
    while(low<hight){
        mid=(low+right)/2;
        if(L.elem[mid]==key)
            return mid;
        else if(L.elem[mid]>key)
            hight=mid-1;
        else
            low=mid+1;
    }
}
```

## 分块查找

又称索引顺序查找

分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块之间是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小千 第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。

## B数和B+树

## 散列表

又称哈希表

### 基本概念

散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记

Hash(key) = Addr（这里的地址可以是数组下标、索引或内存地址等）。

散列函数可能会把两个或两个以上的不同关键字映射到同一地址， 称这种情况为冲突，这些 发生碰撞的不同关键字称为同义词。 一方面，设计得好的散列函数应尽量减少这样的冲突；另一 方面，由千这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。

散列表：根据关键字而直接进行访问的数据结构。 也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。

### 散列函数构造方法

1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖千散列表的大小或地址范围。
2. 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。
3. 散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址。

**直接定址法**

直接取关键字的某个线性函数值为散列地址，散列函数为

​                                 H(key) =key或H(key) = a×key +b

这种方法计算最简单， 且不会产生冲突。它适合关键字的分布基本连续的情况，如果空位较多，就会出现空间浪费。如计算字符串字符出现次数。

**除留余数法**

这是一种最简单、最常用的方法，假定散列表表长为m,取一个不大于m但最接近或等于m的质数p,利用以下公式把关键字转换成散列地址。散列函数为

​                                             H(key) = key %p 

除留余数法的关键是选好p,使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。

**数字分析法**

设关键字是r进制数 （如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合千已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。

**平方取中法**

顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀， 适用千关键字的每位取值都不够均匀或均小千散列地址所需的位数。
在不同的情况 下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决千关键字集合的情况，但目标是尽量降低产生冲突的可能性。



### 处理冲突

**开放定址法**

所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为

​                                     H<sub>i</sub>=(H(key)+d<sub>i</sub>)%m

式中，H(key)为散列函数；i = 0, I, 2,…， k (K<=m- I); m表示散列表表长；di为增量序列。

**拉链法**

显然，对千不同的关键字可能会通过散列函数映射到同 一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标 识。假设散列地址为i的同义词链表的头指针存放在散列表的第i个单元中， 因而查找、 插入和删除操作主要在同义词 链中进行。拉链法适用千经常进行插入和删除的情况。

例如，关键字序列为{19, 14, 23, 01, 68, 20, 84, 27, 55, 11, 10, 79}， 散列函数H(key) =key%13,用拉链法处理冲突，建立的表如图7.9 所示（学完下节内容后， 可以尝试计算本例的平均查找长度ASL)。

### 散列查找及性能分析

初始化：Addr=Hash(key)；

1. 检测查找表中地址为Addr的位置，若无记录，返回**查找失败**；若有记录，比较它与key的值，若相等，则返回**查找成功**，否则执行步骤2
2. 用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转步骤1





# 排序

排序是我们在编程中经常遇到的算法。

## 排序的基本概念

什么是排序？
排序就是重新排列表中的元素，使表中的元素满足关键字有序的过程。

## 思维导图

掌握一种排序算法的首先就要掌握它的思想方法！
![在这里插入图片描述](https://img-blog.csdnimg.cn/3131f80f3bd2473eb1e9d874a14cd05b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfZm0=,size_16,color_FFFFFF,t_70#pic_center)

## 插入排序

  基本思想是每次将一个待排序的记录按其关键字大小插入到前面已经拍好序的子序列中，直到全部记录插入完成。

有一个数组arr[5]={2,1,4,3,5}

 1. 第一个元素是我们已经排序好的，并且我们规定从小到大排
2. 先判断1比2大吗，1小于2，插入到2的前面排序为1，2，4，3，5
3. 再判断4是否比2大，比2大我们不用管它
4. .......

### 直接插入排序

那么要怎么才能实现它呢?
我们记住它的值，每次和它前面的元素比较，如果小了就将元素后移一位。

可以得到实现步骤

1. 找出插入位置k
2. 将L[k,i-1]元素后移一位
3. 将L[i]的值复制到L[k]

```c
void InsertSort(int* nums, int numsSize) {
  if (numsSize < 2)
    return;
  int i = 0;
  for (i = 1; i < numsSize; i++) {
    if (nums[i] < nums[i - 1]) {
      int temp = nums[i];
      int j = 0;
      for (j = i - 1; temp<nums[j]&&j>=0; j--)
        nums[j + 1] = nums[j];
      nums[j + 1] = temp;
    }
  }
}
```

### 折半插入排序

从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作：

>①从前面的有序子表中査找出待插入元素应该被插入的位置；
>②给插入位置腾出空间，将待插入元素复制到表中的插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半
>查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。

当排序表为顺序表时，可以对直接插入排序算法做如下改进：

>由于是顺序存储的线性表，所以査找有序子表时可以用折半查找来实现。
>确定待插入位置后，就可统一地向后移动元素。

算法代码如下：

```c
void InsertSort2(int *nums,int numsSize){
  int i = 0;
  for (i = 1; i < numsSize; i++) {
    int temp = nums[i];
    int left = 0, right = i-1;
    while (left <= right) {
      int mid = (left + right) / 2;
      if (nums[mid] > temp)
        right = mid - 1;
      else
        left = mid + 1;
    }
    for (int j = i - 1; j >= right + 1; j--)
      nums[j + 1] = nums[j];
    nums[right + 1] = temp;
  }
}
```

直接插入排序，找出被插入的位置，移动元素。
折半插入排序：折半找到位置，然后统一移动

### 希尔排序

希尔排序的基本思想是：先将待排序表分割成若干形如[i,i+d,i+2d…,i+nd]的“特殊”子表，即把相隔某个“増量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。



## 交换排序

冒泡排序；快速排序

## 选择排序

基本思想是：每一趙(如第i趟)在后面n-i+1(1=1,2,…,n-1)个待排序元
素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下1个，就不用再选了。

简单选择排序；堆排序

### 简单选择排序

```c
void SelectSort(int* nums, int numsSize) {
  int i = 0,j=0;
  for (i = 0; i < numsSize - 1; i++) {
    int min = i;
    for (j = i + 1; j < numsSize; j++) {
      if (nums[j] < nums[min])
        min = j;
    }
    if (min != i) {
      int temp = nums[min];
      nums[min] = nums[i];
      nums[i] = temp;
    }
  }
}
```

### 堆排序







## 2路归并排序

归并排序和其他的排序不一样，归并排序是将两个已经有序的表合并成为一个新的有序表

## 基数排序

## 外部排序

## 排序算法比较

## 排序算法应用
