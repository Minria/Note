[TOC]

# 复杂度

算法复杂度是指算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。

## 时间复杂度

### 概念的引出

时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。

但是，一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。

但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。

一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。

下面函数的时间复杂度？

```c
void func1(int N){
    int count = 0;
    for (int i = 0; i < N ; i++) {
        for (int j = 0; j < N ; j++) {
            count++;
        }
    }
    for (int k = 0; k < 2 * N ; k++) {
        count++;
    }
    int M = 10;
    while ((M--) > 0) {
        count++;
    }
}
```

我们看见

第一个循环执行了N$^2$次

第二个循环执行了2N次

第三个循环执行10次

所以                                   

​                                                     **F(N)=N$^2$+2N+10**

实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用大O的渐进表示法。

当n的值很大时，影响规模的主要是N$^2$，2N+10的影响微乎其微。

**大O符号（Big O notation）**：是用于描述函数渐进行为的数学符号。

推导大O阶方法：
1、用常数1取代运行时间中的所有加法常数。
2、在修改后的运行次数函数中，只保留最高阶项。
3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。

而且我们一般**关注的是算法的最坏情况**
有些算法的时间复杂度存在最好、平均和最坏情况：
最坏情况：任意输入规模的最大运行次数(上界)
平均情况：任意输入规模的期望运行次数
最好情况：任意输入规模的最小运行次数(下界)
例如：在一个长度为N数组中搜索一个数据x
最好情况：1次找到
最坏情况：N次找到
平均情况：N/2次找到
在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)

常见时间复杂度

- 常数阶O(1)
- 对数阶O(logN)
- 线性阶O(n)
- 线性对数阶O(nlogN)
- 平方阶O(n²)
- 立方阶O(n³)
- K次方阶O(n^k)
- 指数阶(2^n)

### 实战分析

```c
void func(int n,int m){
    int count=0;
    for(int k=0;k<n;k++){
        count++;
    }
    for(int k=0;k<m;k++){
        count++;
    }
}
```

第一个循环执行了n次

第二个循环执行了m次

所以时间复杂度为O(M+N)

```c
void func(int x){
    for(int i=0;i<100;i++){
        x=i;
    }
}
```

我们看到循环执行了一百次那么是O(100)?

100次对我们来说还是有限次时间复杂度为O(1)

```java
void bubbleSort(int[] array) {
    for (int end = array.length; end > 0; end--) {
        boolean sorted = true;    
        for (int i = 1; i < end; i++) {     
            if (array[i - 1] > array[i]) {          
                Swap(array, i - 1, i);            
                sorted = false;        
            }   
        }            
        if (sorted == true) {        
            break;    
        }
    }
}
```

这是一个冒泡排序算法的改进型，我们考虑最坏的情况---改进没有用

仍然执行N<sup>2</sup>次

时间复杂度为O(N<sup>2</sup>)

```java
void binarySearch(int[] array, int value) {
    int begin = 0;
    int end = array.length - 1;
    while (begin <= end) {
        int mid = begin + ((end-begin) / 2);
        if (array[mid] < value)
            begin = mid + 1;
        else if (array[mid] > value)
            end = mid - 1;
        else
            return mid;
    }
    return -1;
}
```

这是一个二分查找，每次砍掉一般，下面我们来对时间复杂度进行证明

*一次查找剩下：N/2*

*二次查找剩下：N/4*

*m次查找剩下：N/2$^m$*

*很倒霉当m次查找是就剩下一个元素了，执行后无论找没找到都要退出*

*N/2$^m$=1可以得出m= $\log_2{N}$*

也就是时间复杂度为O($\log_2{N}$)

```c
long factorial(int N) {
    return N < 2 ? N : factorial(N-1) * N;
}
```

计算N需要N-1，计算N-1需要N-2，知道我们需要计算1

时间复杂度为O(N)

```c
int fibonacci(int N) {
    return N < 2 ? N : fibonacci(N-1)+fibonacci(N-2);
}
```

看下面这个结构

![Snipaste_2021-10-31_20-54-35](https://gitee.com/wang-fuming/dawning/raw/master/202110312054189.png)

我们可以看见呈现指数形式

时间复杂度为O(2$^n$)



## 空间复杂度

### 概念的引出

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。

空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。

空间复杂度计算规则基本跟时间复杂度类似，也使用大O渐进表示法。

### 实战分析

```java
void bubbleSort(int array[]) {
    for (int end = array.length; end > 0; end--) {
        boolean sorted = true;    
        for (int i = 1; i < end; i++) {     
            if (array[i - 1] > array[i]) {          
                Swap(array, i - 1, i);            
                sorted = false;        
            }   
        }            
        if (sorted == true) {        
            break;    
        }
    }
}
```

运行过程中我们借助了少数常量个空间所以空间复杂度为O(1)

需要注意的是

1. 传进来一个数组不是我们耗费的空间，我们是对数组进行**原地操作**
2. 我们看见有一个布尔类型的变量在重复创建好像创建了N次，但占空间只有一次

**解释**

==函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。时间是累积的，而空间是不累积的(可以重复利用)==

```c
int[] fibonacci(int n) {
    long[] fibArray = new long[n + 1];
    fibArray[0] = 0;
    fibArray[1] = 1;
    for (int i = 2; i <= n ; i++) {
        fibArray[i] = fibArray[i - 1] + fibArray [i - 2];
    }
    return fibArray;
}
```

可以清楚看见创建了一个长度为n+1的数组

空间复杂度为O(N)

```c
long factorial(int N) {
    return N < 2 ? N : factorial(N-1)*N;
}
```

递归调用了N次，开辟了N个栈帧，每个栈帧使用了常数个空间。

空间复杂度为O(N)

# 线性表

## 线性表的定义及基本表示

### 线性表的定义

线性表是具有**相同**数据类型的n个数据元素的有限集合。

常见的线性表有顺序表、链表、栈和队列。

### 基本操作

```c
void InitList(&L);//初始化表。构造一个空的线性表。
int Length(L);//求表长。返回线性表L的长度，即L中数据元素的个数。
void LocateElem(L,e);//按值查找操作。在表L中查找具有给定关键字值的元素。
void GetElem(L,i);//按位查找操作。获取表L中第i个位置的元素的值。
void ListInsert(&L,i,e);//插入操作。在表L中的第i个位置上插入指定元素e。
void ListDelete(&L,i,&e);//删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值
void PrintList(L);//输出操作。按前后顺序输出线性表L的所有元素值。
bool Empty(L);//判空操作。若L为空表，则返回true,否则返回false。
void DestroyList(&L);//销毁操作。销毁线性表，并释放线性表L所占用的内存空间。
```

## 顺序表

### 顺序表的定义

**简而言之，数组**。这就是说，顺序表的底层是通过数组来实现的。

静态数组版

```c
//C语言实现
#define MaxSize 50//定义线性表最大长度
struct List{
    int data[MaxSize];//顺序表的元素，以int型数据为例
    int length;//顺序表当前长度，元素个数
}SqList;
```



动态数组版

```c
//C语言实现
#define InitSize 100//表长度初始定义
struct List{
    int* data;//指示动态分配数组的指针
    int MaxSize,length;//数组最大容量和当前容量
}SeqList;
L.data=(int*)malloc(sizeof(int)*InitSize);
int* tmp=(int*)realloc(sizeof(int)*(MaxSize+10));
if(tmp){
    L.data=tmp;//判断扩容成功然后再改变指针指向
}
```

### 顺序表的基本操作

#### 增删查改



建议先看前面的注释了解函数的作用，然后分析增删查改函数

```c
//按顺序访问各元素
void display(Node* list) {
	for (int i = 0; i < list->usedSize; i++)
		printf("%d ", list->data[i]);
	printf("\n");
}
//获取线性表使用长度
int Length(Node* list) {
	return list->usedSize;
}
//在pos处添加元素data，需要保证pos输入合法
void ListInsert(Node *list, int pos, int data) {
	if (pos<0 || pos>list->usedSize) {
		printf("输入位置不合法\n");
		return;
	}
	if (isFull(list)) {
		int* p = (int*)realloc(list->data, list->maxSize + 10);
		if (p == NULL) {
			printf("顺序表满且扩容失败\n");
			return;
		}
		printf("顺序表扩容成功\n初始空间%d\n当前空间%d\n", 10, list->maxSize + 10);
		list->data = p;
		p = NULL;
		list->maxSize += 10;
	}
	for (int i = list->usedSize; i > pos; i--) {
		list->data[i] = list->data[i - 1];
	}
	list->data[pos] = data;
	list->usedSize++;
	printf("添加成功\n");
}
//判断线性表是否满，以便扩容
bool isFull(Node* list) {
	if (list->usedSize == list->maxSize) {
		return true;
	}
	else {
		return false;
	}
}
//判断是否包含某个元素
bool contains(Node* list, int toFind) {
	for (int i = 0; i < list->usedSize; i++) {
		if (list->data[i] == toFind) {
			return true;
		}
	}
	printf("元素不存在");
	return false;
}
//查找某个元素，并返回下标
int search(Node* list, int toFind) {
	for (int i = 0; i < list->usedSize; i++) {
		if (list->data[i] == toFind) {
			return i;
		}
	}
	printf("查找失败");
	return -1;
}
//得到pos的值
int getPos(Node* list, int pos) {
	if (pos < 0 || pos >= list->usedSize) {
		printf("输入位置不合法,返回值-1");
		return -1;
	}
	else {
		printf("找到了");
		return list->data[pos];
	}
}
//删除第一个出现的值
void ListDelete(Node* list, int toRemove) {
	int n = search(list, toRemove);
	if (n < 0) {
		printf("元素不存在\n");
		return;
	}
	for (int i = n; i < list->usedSize-1; i++) {
		list->data[i] = list->data[i + 1];
	}
	list->usedSize--;
	printf("删除成功");
}
//清空表
void DestroyList(Node* list) {
    free(list->data);
	list->usedSize = 0;
	printf("成功清除\n");
}
//main函数主体
int main() {
	Node list;
	list.data = (int*)malloc(4 * MAXSIZE);//采用动态开辟法
	list.usedSize = 0;
	list.maxSize = 10;
/**
这一部分进行操作
*/
     return 0;
}
```



需要着重分析的是增加元素和删除元素

函数接口是`void add(int pos,int data);`

pos是插入位置，data是数值

首先判断pos的合法性，小于0不可以，**大于使用长度也不可以**

合法性判断后判断线性表是否满了，如果满了需要扩容，幸运的是，不用判断扩容的成功与失败。

![Snipaste_2021-10-31_19-58-14](https://gitee.com/wang-fuming/dawning/raw/master/202110312001833.png)

比如我们要在pos为3的位置插入元素，我们就需要将pos以后的元素往后移动一位

如果插入pos为6呢？显然我们不需要移动元素了

那大于使用长度也不可以是什么意思？当我们插入pos=6时，pos等于usedSize的，当大于时，数组下标为6的空间没有被使用，这是不被允许的。

函数删除接口为`void remove(int toRemove)`

对表的删除首先要判断是不是空表，如果时空表我们就不能执行删除操作

然后找到删除元素的下标，如果不存在直接返回并提升不存在

如果存在,就需要后面的元素往前覆盖。

例如，我们要删除pos=2的元素，就要将后面的元素往前覆盖。

![Snipaste_2021-10-31_20-11-13](https://gitee.com/wang-fuming/dawning/raw/master/202110312011715.png)

## 线性表的链式表示

### 单链表的定义

```c
//C语言版
struct LNode{
    int data;//数据域，用一个整数来表示
    struct LNode *next;//指针域，指向下一个结点
};
```

下面给出链表的结构

![Snipaste_2021-11-02_19-04-13](https://gitee.com/wang-fuming/dawning/raw/master/202111021904292.png)

下面给出单链表结构，双链表的结构以及循环单链表结构

![Snipaste_2021-11-02_19-23-51](https://gitee.com/wang-fuming/dawning/raw/master/202111021924585.png)

![Snipaste_2021-11-02_19-23-59](https://gitee.com/wang-fuming/dawning/raw/master/202111021924161.png)

### 链表的建立

```c
//C语言版
//初始化链表
struct LNode* InitList(struct LNode* head){
    head=(struct LNode*)malloc(sizeof(LNode));
    head->next=NULL;
    return head;
}

```

**头插法**

顾名思义，就是再链表的头指针前插入元素

![Snipaste_2021-11-02_20-39-42](https://gitee.com/wang-fuming/dawning/raw/master/202111022040105.png)

```
先前链表1->2->3->4->NULL
我们将5插入链表中
插入后5->1->2->3->4->NULL
```

```c
struct LNode* headInsert(struct LNode* head) {
	struct LNode* p1=(struct LNode*)malloc(sizeof(LNode));
	printf("输入数据>");
	scanf("%d", &(p1->data));//结点的创建
	//核心操作
    p1->next = head;
	head = p1;
	return head;
}

```

**尾插法**

顾名思义，就是再链表的尾端插入

![Snipaste_2021-11-02_20-42-01](https://gitee.com/wang-fuming/dawning/raw/master/202111022042812.png)

```
先前链表1->2->3->4->NULL
将5插入链表后1->2->3->4->5->NULL
```

需要注意的是，**我们需要先前判断头指针是不是空指针**。

```c

struct LNode* tailInsert(struct LNode* head) {
    struct LNode* p2 = (LNode*)malloc(sizeof(LNode));
	printf("输入数据>");
	scanf("%d", &(p2->data));
    if(head==NULL){
        head=p2;
        return head;
    }
    //核心操作
	struct LNode* p1 = head;//p1用来帮助我们找到尾结点，p2用来插入
	while (p1->next) {
		p1 = p1->next;
	}
	p1->next = p2;
	p2->next = NULL;//尾结点后面没有了需要加NULL
	return head;
}
```

```c
//上述尾插法室没有头结点的，如果有头结点，那要怎么插入
struct LNode* tailInsert(struct LNode* head){
    struct LNode*p1=(struct LNode*)malloc(sizeof(LNode));
    p1->next=head->next;
    head->next=p1;
    return head;
}
//@->1->2->3->NULL
//@->4->1->2->3->NULL
```

### 链表的操作

#### 插入节点

```c
void ListInsert(&L,i,e);
```

要想在第i个位置插入元素e，就要找到i-1的位置，假设第i-1个结点是p，然后将新结点q插入其后。

![Snipaste_2021-11-02_22-12-51](https://gitee.com/wang-fuming/dawning/raw/master/202111022213934.png)

```c
q->next=p->next;//步骤1
p->next=q;//步骤2
```

需要说明的是：当执行完步骤1时，1和3都指向2

如果步骤1和2反过来呢?

当我们`p->next=q`后，我们就丢失后面的结点

此时就是`1->3->null`连接

在很多境况我们采用的是尾插法，那要是插在头节点前呢？

可以使用头插法，也可以弄一个头节点来操作。

#### 删除结点

**删除结点需要找到前驱结点**

假设p为前驱结点

```c
q=p->next;
p->next=q->next;
free(q);
```

![Snipaste_2021-11-02_22-24-13](https://gitee.com/wang-fuming/dawning/raw/master/202111022224992.png)

缺点是无法找到头节点的前驱结点

**也可以将后面结点覆盖前面结点**

假设p为被删除结点

```c
q=p->next;
p->data=q->data;
p->next=q->next;
free(q);
```

![Snipaste_2021-11-02_22-30-15](https://gitee.com/wang-fuming/dawning/raw/master/202111022230120.png)

需要注意的，==第一个结点不能删除头结点，第二个方法不能删除尾结点。==

第一个可以单独判头指针，但是尾指针判断较为困难

对于常规插入删除好像都不能顾全面，这时候可以在前面加一个哑结点，那样就不能考虑对头节点插入删除的困扰。

## 双链表

```c
struct List{
    int data;
    struct List* next;//指向后驱节点
    struct List* prior;//指向前驱节点
};
```

### 操作

#### 删除操作

```c
p->prior->next=p->next;
p->next->prior=p->prior;
free(p);
```

![Snipaste_2021-11-11_20-45-10](https://gitee.com/wang-fuming/dawning/raw/master/202111112045217.png)

需要注意的是

1、对节点的操作和尾节点操作比较简单，不需要这么复杂

2、需要单独考虑只有一个元素并且执行删除操作

#### 添加操作

```c
p->prior->next=q;
q->prior=p->prior;
q->next=p;
p->prior=q;
```

![QQ截图20211111205755](https://gitee.com/wang-fuming/dawning/raw/master/202111112058815.png)





# 栈

## 栈的基本概念

### 栈的定义

1. 栈（Stack）是只允许在一段进行插入或者删除的**线性表**。
2. 栈顶（Top）。线性表允许进行插入删除的那一端。
3. 栈底（Bottom）。固定，不允许插入删除。
4. 空栈。不含任何元素。

### 栈的基本操作

```c
void initStack(&S);//初始化一个空栈s。
bool empty(S);//判断一个栈是否为空， 若栈s 为空则返回true,否则返回false。
bool push(&S,x);//进栈，若栈s未满， 则将x加入使之成为新栈顶。
bool Pop(&S,&x);//出栈，若栈s非空，则弹出栈顶元素， 并用x返回。
bool getTop(S,&x);//读栈顶元素，若栈s非空， 则用x返回栈顶元素。
bool destroyStack(&S);//销毁栈， 并释放栈s占用的存储空间。
```

### 栈的存储结构

#### 顺序栈

```c
#define MaxSize 50//栈中元素最大个数
typedef struct{
    int data[MaxSize];//存放栈中元素
    int top;//栈顶指针
}SqStack;
```

栈顶指针：S.top,初始时**设置s.top=-1**;

栈顶元素：S.data[S.top]；

进栈操作：栈不满时， 栈顶指针先加1,再送值到栈顶元素；

出栈操作：栈非空时， 先取栈顶元素值， 再将栈顶指针减1 ；

栈空条件：S.top= =-1; 

栈满条件：S.top= =MaxSize-1;

栈长：S.top+1。

**基本操作**

初始化

```c
//初始化
void initStack(SqStack &S){
    S.top=-1;
}
//判断栈空
bool empty(SqStack S){
    if(S.top==-1)
        return true;
    else
        return false;
}
//进栈
void push(SqStack &S,int x){
    if(S.top==MaxSize-1)
        return false;
    else
        S.data[++S.top]=x;
    return true;
}
//出栈
int pop(SqStack &S,int* x){
    if(S.top==-1)
        return -1;
    else
        x=S.data[S.top--];
    return true;
}
//读栈顶元素
bool getTop(SqStack &S,int* x){
    if(S.top==-1)
        return false;
    x=S.data[s.top];
    return true;
}
```



#### 链式栈

```c
typedef struct LinkNode{
    int data;
    struct Linknode *next;
}*LiStack;
```

> 插入删除在表头执行

```c
void push(struct Linknode* S,int e){
    p=(struct linkNode*)malloc(sizeof(LinkNode));
    p->data=e;
    p->next=S;
    S=p;
    return true;
}
int pop(struct Linknode* S,int* e){
    if(S==NULL)
        return false;
    e=S->data;
    struct Linknode* p=S;
    S=S->next;
    free(p);
    return true;
}
```

## 单调栈



## 栈的应用

**出入栈顺序合法性**

**表达式转换**



# 队列

## 队列的基本概念

### 队列的定义

队列（Queue），也是一种操作受限的线性表，只允许在一段进行插入并且在另一端进行删除。

### 队列的操作

```c
void InitQueue(&Q);//初始化队列，构造一个空队列Q。
bool QueueErnpty(Q);//判队列空，若队列Q为空返回七rue,否则返回false。
void EnQueue(&Q,x);//入队，若队列Q未满，将x加入，使之成为新的队尾。
void DeQueue(&Q,x);//出队，若队列Q非空，删除队头元素，并用x返回。
void GetHead(Q, &x);//读队头元素，若队列Q非空，则将队头元素赋值给x。
```

### 队列的存储结构

#### 顺序队

```c
#define MaxSize 50//定义队列中元素的最大个数
typedef struct{
int data[MaxSize];//存放队列元素
int front,rear;//队头指针和队尾指针
}SqQueue;
```

初始状态（队空条件）：Q.front = =Q.rear= = 0。

进队操作：队不满时， 先送值到队尾元素， 再将队尾指针加1。

出队操作：队不空时， 先取队头元素值， 再将队头指针加1。

#### 循坏队



#### 链式队

```c
typedef struct{
    int data;
struct LinkNode *next;
}LinkNode;
typedef struct{ 
    LinkNode *front,*rear; ／／队列的队头和队尾指针
}LinkQueue; 
```



```c
void initQueue(LinkQueue &Q){
    Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));
    Q.front->next=NULL;
}
bool isEmpty(LinkQueue Q){
    if(Q.front==Q.rear)
        return true;
    else
        return false;
}
void enQueue(LinkQueue &Q,int x){
    LinkNode* s=(LinkNode*)malloc(sizeof(LinkNode));
    s->data=x;
    s->next=NULL;
    Q.rear->next=s;
    Q.rear=s;
}
bool deQueue(LinkQueue &Q,int* x){
    if(Q.front==Q.rear)
        return false;
    LinkNode*p=Q.front->next;
    x=p->data;
    Q.front->next=p->next;
    if(Q.rear==p)
        Q.rear=Q.front;
    free(p);
    return true;
}
```

## 双端队列

# 树和二叉树

## 树的基本概念

### 树的定义

树是n个结点的有限集。当n=0时，称为空树。

1. 有且仅有一个根结点
2. 当n>1时，其余结点可以分为m个互不相交的有限集，每个集合又是一棵树。

树的特点

1. 树的根结点没有前驱，除了根结点外的所有结点都有且只有一个前驱
2. 树中所有结点可以有零个或者多个后继。

### 基本术语

![Snipaste_2021-10-11_19-10-59](https://gitee.com/wang-fuming/dawning/raw/master/202110111911531.png)



1、考虑结点K。 根A到结点K的唯 路径上的任意结点，称为结点K的祖先。 如结点B 是
结点K的祖先， 而结点K是结点B的子孙。 路径上最接近结点K的结点E称为K的双
亲， 而K为结点E的孩子。 根A是树中唯有双亲的结点。 有相同双亲的结点称为兄弟， 如结点K和结点L有相同的双亲E, 即K和L为兄弟。

2、树中个结点的孩子个数称为该结点的度， 树中结点的最大度数称为树的度。 如结点 B
的度为2, 结点D的度为3 ,树的度为3。

3、度大千0的结点称为分支结点 （又称非终端结点）；度为0（没有子女结点） 的结点称为
叶子结点（又称终端结点）。 在分支结点中， 每个结点的分支数就是该结点的度。

4、结点的深度、 高度和层次。

结点的层次从树根开始定义， 根结点为第1层， 它的子结点为第2层， 以此类推。 双亲在同一层的结点互为堂兄弟， 图5.1中结点G与E,F, H, I, J互为堂兄弟。结点的深度是从根结点开始自顶向下逐层累加的。结点的高度是从叶结点开始自底向上逐层累加的。
树的高度 （或深度） 是树中结点的最大层数。 图5.1中树的高度为4。

5、有序树和无序树。 树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。 假设图5.1为有序树，若将子结点位置互换， 则变成 棵不同的树。

6、路径和路径长度。 树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的， 而路径长度是路径上所经过的边的个数。
**注意**： 由于树中的分支是有向的， 即从双亲指向孩子， 所以树中的路径是从上向下的， 同一双亲的两个孩子之间不存在路径。

### 树的性质

> 1. 树中结点数等于所有结点的度数之和加1.
> 2. 度为m的数中第i层至多有m<sup>i-1</sup>个结点
> 3. 高度为h的m叉数至多有（m<sup>h</sup>-1）/(m-1)个结点
> 4. 具有n个结点的m叉数最小高度时log<sub>m</sub>(n(m-1)+1)



## 二叉树

### 二叉树的定义及主要特性

#### 二叉树的定义

二叉树也是一种树形结构，其特点是每个结点至多只有两个子树，并且二叉树的子树有左右之分，其次序不能任意颠倒。

#### 特殊的二叉树

![Snipaste_2021-10-11_19-13-10](https://gitee.com/wang-fuming/dawning/raw/master/202110111913714.png)

1. 满二叉树

   一颗树的高度为h，且含有2<sup>k</sup>-1个节点。

2. 完全二叉树

### 二叉树的性质

若规定根节点的层数为1，则一颗非空二叉树的第i层最多放2<sup>i-1</sup>个节点

若规定只有根节点的深度为1，则深度为k的二叉树的

### 二叉树的存储结构

```c
typedef struct TreeNode{
    int data;
    struct TreeNode *lchild,*rchild;
}TreeNode;
```

### 二叉树的遍历

1、先序遍历

操作如下

如果是空树，什么也不做，否则

1. 访问跟结点
2. 遍历左子树
3. 遍历右子树

```c
//伪代码
//递归形式
void Preorder(TreeNode T){
    if(T){
        visit(T);
        Inorder(T->lchild);
        Inorder(T->rchild);
    }
}
void PreOeder(TreeNode T){
    InitStack(S);//初始化一个栈
    BiTree p=T;
    while(p||!Empty(S)){
        if(p){
            visit(p);
            Push(S,p);
            p=p->lchild;
        }
        else{
            Pop(S,p);
            p=p->rchild;
        }
    }
}
```

![Snipaste_2021-11-03_17-12-54](https://gitee.com/wang-fuming/dawning/raw/master/202111031714849.png)



2、中序遍历

操作如下

如果是空树，什么也不做，否则

1. 遍历左子树
2. 访问根结点
3. 遍历右子树



```c
//伪代码
//递归形式
void Inorder(TreeNode T){
    if(T){
        Inorder(T->lchild);
        Visit(T);
        Inorder(T->rchild);
    }
}
//非递归，借助栈来完成
void InOeder(TreeNode T){
    InitStack(S);//初始化一个栈
    BiTree p=T;
    while(p||!Empty(S)){
        if(p){
            Push(S,p);
            p=p->lchild;
        }
        else{
            Pop(S,p);
            visit(p);
            p=p->rchild;
        }
    }
}
```



3、后序遍历

操作如下

如果是空树，什么也不做，否则

1. 遍历左子树
2. 遍历右子树
3. 访问根结点   

```c
void PostOrder(TreeNode T){
    if(T){
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        visit(T);
    }
}
void PostOrder(TreeNode T){
    InitStack(S);
    BiTree p=T;
    r=NULL;
    while(p||!Empty(S)){
        if(p){
            Push(S,p);
            p=p->lchild;
        }
        else{
            GetTop(S,p);
            if(p->rchlid&&p->rchild!=r){
                p=p->rchild;
            }
            else{
                Pop(S,p);
                visis(p);
                r=p;
                p=NULL;
            }            
        }
    }
}
```

4. 层次遍历

```c
void LeverOrder(TreeNode T){
    InitQueue(Q);
    BiTree p;
    EnQueue(Q,T);
    while(!IsEmpty(Q)){
        DeQueue(Q,p);
        visit(p);
        if(p->lchild)
            EnQueue(Q,p->lchild);
        if(p->rchild)
            EnQueue(Q,p->rchild);
    }
}
```



### 线索二叉树

#### 线索二叉树的基本概念

```c
typedef struct ThreadNode{
    int data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;
}ThreadNode,*ThreadTree;
```

## 树和森林

### 树的存储结构

1. 双亲表示法

```c
#define MAX_TREE_SIZE 100
typedef struct{
    int data;
    int parent;
}PTNode;
typedef struct{
    PTNode nodes[MAX_TREE_SIZE];
    int n;
}PTree;
```

2. 孩子表示法
3. 孩子兄弟表示法

```c
typedef struct CSNode{
    int data;
    struct CSNode *firstchild,*nexts;
}CSNode,*CSTree;
```

# 图

## 图的储存和基本操作

1. 邻接矩阵法

```c
#define MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;
typedef struct{
    VertexType Vex[MaxVertexNum];//顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];//领接矩阵
    int vexnum,arcnum;//当前顶点数和弧数
}
```



# 查找

## 顺序查找

1. 对于顺序表，可通过数组下标扫描

2. 对于链表，可通过next指针进行扫描

### 一般表的顺序查找

基本思想:从线性表一端开始，逐个检查关键字是否满足条件

```c
typedef struct{
    int* elem;
    int TableLen;
}SSTable;
int Search_Seq(SSTable ST,int key){
    ST.elem[0]=key;
    for(i=ST.TableLen;ST.elem[i]!=key;--i)
        return i;
}
```

### 有序表的顺序查找

## 折半查找

又称二分查找，**仅适用有序表**

```c
int BinarySearch(SeqList L,int key){
    int low=0,hight=L.TableLen-1,mid;
    while(low<hight){
        mid=(low+right)/2;
        if(L.elem[mid]==key)
            return mid;
        else if(L.elem[mid]>key)
            hight=mid-1;
        else
            low=mid+1;
    }
}
```

## 分块查找

又称索引顺序查找

分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块之间是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小千 第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。

## B数和B+树

## 散列表

又称哈希表

### 基本概念

散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记

Hash(key) = Addr（这里的地址可以是数组下标、索引或内存地址等）。

散列函数可能会把两个或两个以上的不同关键字映射到同一地址， 称这种情况为冲突，这些 发生碰撞的不同关键字称为同义词。 一方面，设计得好的散列函数应尽量减少这样的冲突；另一 方面，由千这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。

散列表：根据关键字而直接进行访问的数据结构。 也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。

### 散列函数构造方法

1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖千散列表的大小或地址范围。
2. 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。
3. 散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址。

**直接定址法**

直接取关键字的某个线性函数值为散列地址，散列函数为

​                                 H(key) =key或H(key) = a×key +b

这种方法计算最简单， 且不会产生冲突。它适合关键字的分布基本连续的情况，如果空位较多，就会出现空间浪费。如计算字符串字符出现次数。

**除留余数法**

这是一种最简单、最常用的方法，假定散列表表长为m,取一个不大于m但最接近或等于m的质数p,利用以下公式把关键字转换成散列地址。散列函数为

​                                             H(key) = key %p 

除留余数法的关键是选好p,使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。

**数字分析法**

设关键字是r进制数 （如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合千已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。

**平方取中法**

顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀， 适用千关键字的每位取值都不够均匀或均小千散列地址所需的位数。
在不同的情况 下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决千关键字集合的情况，但目标是尽量降低产生冲突的可能性。



### 处理冲突

**开放定址法**

所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为

​                                     H<sub>i</sub>=(H(key)+d<sub>i</sub>)%m

式中，H(key)为散列函数；i = 0, I, 2,…， k (K<=m- I); m表示散列表表长；di为增量序列。

**拉链法**

显然，对千不同的关键字可能会通过散列函数映射到同 一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标 识。假设散列地址为i的同义词链表的头指针存放在散列表的第i个单元中， 因而查找、 插入和删除操作主要在同义词 链中进行。拉链法适用千经常进行插入和删除的情况。

例如，关键字序列为{19, 14, 23, 01, 68, 20, 84, 27, 55, 11, 10, 79}， 散列函数H(key) =key%13,用拉链法处理冲突，建立的表如图7.9 所示（学完下节内容后， 可以尝试计算本例的平均查找长度ASL)。

### 散列查找及性能分析

初始化：Addr=Hash(key)；

1. 检测查找表中地址为Addr的位置，若无记录，返回**查找失败**；若有记录，比较它与key的值，若相等，则返回**查找成功**，否则执行步骤2
2. 用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转步骤1





# 排序

排序是我们在编程中经常遇到的算法。

## 排序的基本概念

什么是排序？
排序就是重新排列表中的元素，使表中的元素满足关键字有序的过程。

## 思维导图

掌握一种排序算法的首先就要掌握它的思想方法！
![在这里插入图片描述](https://img-blog.csdnimg.cn/3131f80f3bd2473eb1e9d874a14cd05b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfZm0=,size_16,color_FFFFFF,t_70#pic_center)

## 插入排序

  基本思想是每次将一个待排序的记录按其关键字大小插入到前面已经拍好序的子序列中，直到全部记录插入完成。

有一个数组arr[5]={2,1,4,3,5}

 1. 第一个元素是我们已经排序好的，并且我们规定从小到大排
2. 先判断1比2大吗，1小于2，插入到2的前面排序为1，2，4，3，5
3. 再判断4是否比2大，比2大我们不用管它
4. .......

### 直接插入排序

那么要怎么才能实现它呢?
我们记住它的值，每次和它前面的元素比较，如果小了就将元素后移一位。

可以得到实现步骤

1. 找出插入位置k
2. 将L[k,i-1]元素后移一位
3. 将L[i]的值复制到L[k]

```c
void insertSort(int* nums, int numsSize) {
	for (int i = 1; i < numsSize; i++) {
		if (nums[i] < nums[i - 1]) {
			for (int j = i; j>=1&&nums[j] < nums[j - 1]; j--) {
				int tmp = nums[j];
				nums[j] = nums[j - 1];
				nums[j - 1] = tmp;
			}
		}
	}
}
```

### 折半插入排序

从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作：

>①从前面的有序子表中査找出待插入元素应该被插入的位置；
>②给插入位置腾出空间，将待插入元素复制到表中的插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半
>查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。

当排序表为顺序表时，可以对直接插入排序算法做如下改进：

>由于是顺序存储的线性表，所以査找有序子表时可以用折半查找来实现。
>确定待插入位置后，就可统一地向后移动元素。

算法代码如下：

```c
void InsertSort2(int *nums,int numsSize){
  for (int i = 1; i < numsSize; i++) {
    int temp = nums[i];
    int left = 0, right = i-1;
    while (left <= right) {
      int mid = (left + right) / 2;
      if (nums[mid] > temp)
        right = mid - 1;
      else
        left = mid + 1;
    }
    for (int j = i - 1; j >= right + 1; j--)
      nums[j + 1] = nums[j];
    nums[right + 1] = temp;
  }
}
```

直接插入排序，找出被插入的位置，移动元素。
折半插入排序：折半找到位置，然后统一移动

### 希尔排序

希尔排序的基本思想是：先将待排序表分割成若干形如[i,i+d,i+2d…,i+nd]的“特殊”子表，即把相隔某个“増量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。



## 交换排序

冒泡排序；快速排序

### 冒泡排序

```c
void bubbleSort(int* nums, int numsSize) {
	for (int i = 0; i < numsSize; i++) {
		bool flag = false;
		for (int j = numsSize - 1; j > i; j--) {
			if (nums[j] < nums[j - 1]) {
				int tmp = nums[j];
				nums[j] = nums[j - 1];
				nums[j - 1] = tmp;
				flag = true;
			}
		}
		if (flag == false) {
			break;
		}
	}
}
```

### 快速排序

```c
void quickSort(int* nums, int left, int right) {
	if (left >= right) return;
	int i = left, j = right;
	int tmp = nums[i];
	while (i < j) {
		while (i < j && nums[j] >= tmp) {
			j--;
		}
		nums[i] = nums[j];
		while (i < j && nums[i] <= tmp) {
			++i;
		}
		nums[j] = nums[i];
	}
	nums[i] = tmp;
	quickSort(nums, left, i);
	quickSort(nums, i + 1, right);
}
```



## 选择排序

基本思想是：每一趙(如第i趟)在后面n-i+1(1=1,2,…,n-1)个待排序元
素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下1个，就不用再选了。

简单选择排序；堆排序

### 简单选择排序

```c
void selectSort(int* nums, int numsSize) {
	for (int i = 0; i < numsSize; i++) {
		int min = nums[i];
		int flag = i;
		for (int j = i + 1; j < numsSize; j++) {
			if (nums[j] < min) {
				min = nums[j];
				flag = j;
			}
		}
		if (flag != i) {
			int tmp = nums[i];
			nums[i] = nums[flag];
			nums[flag] = tmp;
		}
	}
}
```

### 堆排序

```c
void heapSort(int* nums, int numsSize) {
	for (int i = numsSize / 2 - 1; i >= 0; i--) {
		adjustHeap(nums, i, numsSize);
	}
	for (int j = numsSize - 1; j > 0; j--) {
		int tmp = nums[0];
		nums[0] = nums[j];
		nums[j] = tmp;
		adjustHeap(nums, 0, j);
	}
}
void adjustHeap(int* nums, int i, int numsSize) {
	int temp = nums[i];
	for (int k = i * 2 + 1; k < numsSize; k = k * 2 + 1) {
		if (k + 1 < numsSize && nums[k] < nums[k + 1]) {
			k++;
		}
		if (nums[k] > temp) {
			nums[i] = nums[k];
			i = k;
		}
		else {
			break;
		}
	}
	nums[i] = temp;
}
```







## 2路归并排序

归并排序和其他的排序不一样，归并排序是将两个已经有序的表合并成为一个新的有序表

## 基数排序

## 外部排序

## 排序算法比较

## 排序算法应用
