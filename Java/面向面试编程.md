# 面试题分析

**什么是面向对象？谈谈对面向对象的理解**

```
说到面向对象，就要和面向过程进行对比来理解
这是两种处理问题的角度
面向过程更加注意事情处理的步骤以及顺序，执行起来执行高效
而面向对象更加注重参与者有谁，以及他们都做了什么，代码易于复用更新以及维护
比如洗衣服
面向过程的角度：打开洗衣机->放入衣服->清洗->烘干
面向对象的角度：分解为人和洗衣机两个对象
人要做的就是打开洗衣机以及放入衣服
洗衣机要做的就是清洗和烘干
面向对象的三大特性
封装
	隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别
继承
	子类继承父类
多态
	父类引用指向子类对象，并且调用了子类重写的父类方法
```

**JDK、JRE、JVM的区别**

```
JDK:Java开发环境（包含JRE和JVM）
JRE：Java运行环境（包含JVM）
JVM：Java虚拟机
```

**==和equlas的区别**

```
==是比较栈的中值，基本数据类型就是变量值，对于引用类型就是堆中对象的地址
equlas默认调用的比较方式也是==，但是通常对其重写，让他可以比较内容
例如，String和包装类型的euqlas方法就被重写
```

**final的作用，以及为什么局部内部类以及匿名内部类只能访问局部的final方法**

```
1、修饰变量，表示常量,不可被修改
	a）修饰类变量，声明时赋值，或者在静态代码块中赋值
	b）修饰成员变量，声明时赋值，代码块中赋值，或者构造器中赋值、
	c）修饰局部变量，可以在定义时赋值，也可以在使用前进行赋值，只可以赋值一次
		1）需要注意的是，引用类型不可以改变指向的对象，但是可以更改对象的内容
2、修饰类，表示类不可被继承

3、修饰方法，表示类被继承后方法不可被重写(可以被重载）

4、局部内部类和匿名内部类在编译的时候也会生成.class文件，也就是说内部类和外部类是同一个级别
当外部类的方法执行完后，局部变量应该销毁掉，但是内部类还有可能存在，这样就有可能产生：内部类访问一个不存在的局部变量。为了解决这个问题，就将内部类copy一份，演出了局部变量的生命周期
但是也要保证两个两个变量的值一样，加一个final保证值不变。

```

**String、StringBuilder、StringBuffer**

```
String是final修饰的不可变的，每次对它的操作都会产生一个新的对象
StringBuilder和StringBuffer是可变的，每次操作都是在原对象上进行操作
两者的区别就是前者是线程不安全，后者是线程安全的。
StringBuffer的方式使用了锁
在性能上：StringBuilder>StringBuffer>String
应对使用场景
频繁修改字符串优先使用StringBuilder
多线程共享变量使用StringBuffer
```

**重写和重载的区别**

```
重载：发生在一个类中，方法名相同，但是参数的类型不同，顺序不同，个数不同。方法的返回值和访问权限可以不同，发生在编译时期
重写：发生在父类子类中，方法名、参数列表必须相同，返回值的返回小于等于父类，抛出的异常范围小于等于父类，访问的范围大于等于父类。如果父类的修饰是private，子类不能重写。
```

**接口和抽象类的区别**

```
1、抽象类可以存在普通的函数，接口里面全部都是public abstract
2、抽象类中的成员变量可以任意类型的，而接口中的成员变量都是public static final
3、只能继承一个抽象类，但是可以实现多个接口
从设计目的上分析
	接口的目的是对类的行为进行约束，它可以让不同的类具有相同的行为。它只约束行为的有无，并不关心怎实现。
	抽象类的设计的目的是为了代码复用，当不同的类具有某些相同的行为，并且一部分的实现一致时，可以让这些类派生出一个抽象类
	抽象类是对本质的抽象，表示is a
	接口是对行为的描述，表示like
```

**HashCode和equlas**

```
HashCode目的是获取对象在堆中的哈希码，又称散列值，它表示对象在哈希表中的索引位置。任何类都有这个函数
以HashSet为例说明
	当你创建一个新对象时，通过HashCode找到下标，如果下标已经存在，产生哈希冲突，使用equlas判断是不是一个对象，如果是一个对象，那就插入失败，否则，插入成功。
两个对象相同时，他们的哈希值相同。反之，不成立。
两个对象相同，调用equlas返回true。
equlas被重写后，HashCode也必须被重写。否则即使相同也不会判断为相同
```

**List和Set的区别**

```
List：有序，并且按照对象进入的顺序进行排序，可重复，允许null，可以通过迭代器取出元素，也可以通过get（）取出
Set：无序，不可重复，最多允许一个null，只能通过迭代器一一遍历取出
```

**ArrayList和LinkedList的区别**

```
ArrayList：基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动（往后复制一份，插入新元素），使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList（需要创建大量的node对象）

LinkedList：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐一遍历遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需要对list重新进行遍历，性能消耗极大。

另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。
```

**HashMap和HashTable有什么区别？其底层实现是什么？**

```
1、区别 ：
（1）HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；
（2）HashMap允许key和value为null，而HashTable不允许
2、底层实现：数组+链表实现
jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组，
如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表。key为null，存在下标0的位置
数组扩容
```

**ConcurrentHashMap原理，jdk7和jdk8版本的区别**

```
jdk7：
数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构

元素查询：二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部锁：
Segment分段锁 Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment

get方法无需加锁，volatile保证

jdk8：
数据结构：synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性查找，替换，赋值操作都使用CAS锁：锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写
操作、并发扩容

读操作无锁：

Node的val和next使用volatile修饰，读写线程对该变量互相可见

数组用volatile修饰，保证扩容时被读线程感知
```

